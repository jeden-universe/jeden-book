
# The Jeden Language

The current version of the Jeden language is the `alonzo` release. The name honors Alonzo Church, the inventor of lambda calculus. This first release establishes the core engine of Jeden based on lambda calculus. All data structures are Church-encoded as closed lambda-terms. The type system extends simple types with support dependent types.

## Language Specification
*This section is normative*

### Grammar

The `alonzo` release of the Jeden interpreter parses the following grammar.

```
    start      ::= module*
    
    module     ::= '#module' var INDENT (typedef | termdecl termdef)* UNINDENT
    
    typedef    ::= var var* '::=' type
    
    termdecl   ::= var '::' type
    termdef    ::= var ':=' term
    
    type       ::= '(' type ')'
                |  var ( ':' vartype | var+ )? ( '->' type )?
    vartype    ::= '(' type ')' | var var*
    
    term       ::= '(' term ')'
                |  '\' var+ '.' term
                |  var (var | '(' term ')')*
```

### Semantic conditions

##### Module name
The module name following the `#module` keyword transitions from free to bound in the list of module names currently in scope.

##### Type definition
The name of the type being defined is the first identifier appearing in the type definition.

The name transitions from globally free to bound.

The name of the type arguments, if any, follow the first identifier appearing in the type definition.

The type of the type being defined is `(Type ->)* Type`, where the number of prefixes equals the number of arguments.

The type arguments transition from locally free to bound, each with type `Type`.

A valid type appears after the `::=` symbol. The validity check starts with the type arguments, if any, as the only locally bound variables.

##### Type Validation
The validation of a type is performed by cases.

  * case `( A )`: Create a nested local scope and check `A` inside that scope.
  * case `A -> B`: Validate the type `A`, then validate the type `B`, keeping the local variables generated by the validation of `A`.
  * case `x : B`: The variable `x` transitions from locally free to bound. Validate the type `B`.
  * case `a b*`: All variables may be bound, locally, globally, or both. Local definitions take priority over global ones. If a variable is free, it is added to the context and tagged as free. Unify `a` with its arguments `b*` and update local variables accordingly.

A variable appearing on a right-hand side and tagged as free after validation is semantically equivalent to a `forall` type.

##### Term Declaration
The name of the term being declared appears left of the `::` symbol.

The type appearing right of the `::` symbol is validated.

##### Term Definition
  * case lambda term `\var+. term`: Create a nested local scope and check the term inside that scope.
  * case `var <arg>*`: The variable `var` must be bound, either locally or globally. Local definitions take precedence. Validate each argument term independently.

##### Type Inference
Type inference consists in constructing a type from scratch given a lambda-term. It is assumed that the term is validated in terms of variable scope. It is also assumed that all global variables have a known constant associated type. Inference therefore consists in assigning types to local variables.

##### Type Checking
Type checking consists in verifying that the inferred type of a term definition is compatible with the type given in the term declaration. The type checking strategy is to first infer the type of the defined term, then to unify with the declared type. The declared type must be equal or more defined than the inferred type.
